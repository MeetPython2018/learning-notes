### JavaScript

> JavaScript是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在[HTML](https://baike.baidu.com/item/HTML)（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 

#### 引入js

> js的几种引入方式是互相关联的，可以互相操作和访问
>
> 外部js中不能有<script>标签对
>
> 嵌入式js中不能添加src属性

- 外链式

```html
<script src='index.js'></script>
```

- 嵌入式

```html
<script>
	alert('hello world!')
</script>
```

- 事件后

```html
<button onclick='alert(123)'></button>
```

#### js中的调试工具

- 弹出框

```js
alter(123);
```

- 输出到控制台

```js
console.log('123');
```

- 输出到页面中(可以识别标签对)

```js
document.write("a");
document.write("<h3>这是H3级标题</h3>")
```

- 输入框

```js
prompt("请输入:")
```

### 定义一个变量

> 变量：一个用来存储数据的容器

#### 变量的命令规范

> js中的变量名必须由字母、数字、下划线、$组成

- 不能以数字开头
- 区分大小写
- 不能以关键字命名
- 不能以保留字命名
- 命名最好有意义
- 首字母大写
- 采用驼峰命名法

#### 变量的赋值

- 先声明再赋值

```js
var num;
num = 100;
```

- 声明的同时赋值

```js
var num = 100;
```

- 一次声明多个变量，在赋值

```js
var a, b, c;
a = 1,b = 2,c = 3;
```

- 一次声明多个变量并赋值

```js
var a = 6, b = 80, c = 100;
```

#### 注意事项

- 变量要先声明后访问，默认值为：`undefined`
- 新值覆盖旧值
- 变量可以重复声明
- 不用var关键字声明变量，但赋值，不会报错，此时变量为全局变量
- 不用var关键字声明，也不赋值，会报错
- 先访问后声明，值为 `undefined`，预解析（var function）

### 数据类型

> 根据数据在内存中存储的位置进行划分，基本数据类型存放在栈中，引用型数据存放在堆中

#### 基本数据类型

- undefined
- null
- number

```js
二进制：0b开头     0---7
八进制：0o开头     0,1
十进制：0d开头
十六进制：0x开头   0--9+A--F
NaN：not a number      # 本来期望返回数值的操作但并未返回数值的操作
```

- boolean

- string

  - 转义字符

  ```js
  \'   \"   \t   \n   \r
  ```

#### 引用数据类型

> object （属性与方法的集合）  -->   数组  函数  对象

#### 变量的数据类型

| 数据类型  | 值                        | typeof    |
| --------- | ------------------------- | --------- |
| undefined | undefined                 | undefined |
| null      | null(空占位符)            | object    |
| number    | 整数、浮点数、小数        | number    |
| string    | ""         ''      ``+${} | string    |
| boolean   | true/false                | boolean   |
| object    | 数组、函数、对象          | object    |

### 运算符

#### 算术运算符

```js
+   -   *   /   %   ++var   var++  --var   var--
```

##### +的二义性

- 操作数都是数值时进行四则运算
- 操作数包含字符串时，进行拼接

##### 自增、自减的用法

```js
++var      # ++在前时，先自增再使用var的值
var++      # ++在后时，先使用var的值再自增
#  --的用法与之类似
```

#### 关系运算符

> 关系运算符的返回值为true或者false

```js
>   <   >=   <=   ==(值相同)   ===(不仅值相同，数据类型也要一致)   ！=    ！==
```

- 如果两个操作数都是字符串（数值型字符串），按照ASSCII表比较其首字符的大小
- 如果两个操作数都是数字，直接比较大小
- 如果一个操作数是数字，另一个操作数是字符串，先尝试将字符串转换为数字，如果转换成功，则按数字大小进行比较，不成功则返回false

#### 赋值运算符

```js
=   +=   -=   *=   /=   %=
```

#### 逻辑运算符

> 比较值与变量之间的逻辑关系
>
> 值为false有：0、false、undefined、null、NaN、''
>
> &&  逻辑与       ||逻辑或         ！逻辑非

##### 逻辑运算符真值表

| A     | B     | A&&B  | A\|\|B | !A    |
| ----- | ----- | ----- | ------ | ----- |
| true  | true  | true  | true   | false |
| true  | false | false | true   | false |
| false | false | false | false  | true  |
| false | true  | false | true   | true  |

###### 返回值

- &&   

  > 同真为真，返回第一个假值，没有假值时返回最后一个真值

- ||

  > 同假为假，返回第一个真值，没有真值时返回最后一个假值

- ！

  > 取反，返回值true/false

#### 三元运算符

```js
表达式？ 语句1：语句2；
```

> 表达式的结果为真执行语句1 ，为假执行语句2

### 流程控制

> 代码按照指定条件的执行顺序
>
> 1.顺序结构      2.分支结构      3.循环结构

#### 顺序结构

> 语句按照从上到下的结构依次执行

#### 分支结构

> 当条件成立时执行相应的语句

- 单分支

  ```js
  if(条件){
     条件成立时，执行的语句;
     }
  ```

- 双分支

  ```js
  if(条件){
     条件成立时，执行的语句;
     }
  else{
      条件不成立时执行的语句;
  }
  ```

- 多分支

  ```js
  if(条件1){
     条件1成立时执行的语句;
  }
  else if(条件2){
     条件1不成立，条件2成立时执行的语句;
  }
  else if(条件3){
     条件1不成立，条件2不成立，条件3成立时执行的语句;
  }
  else{
      以上条件均不成立时，执行的语句;
  }
  ```

- 嵌套分支

  ```js
  if(){
     if(){}
     }
     else{
         if(){}
     }
  ```

- switch

  ```js
  switch(表达式){
          case "值1"：语句1；break;
          case "值2"：语句2；break;
          case "值3"：语句3；break;
          case "值4"：语句4；break;
          ...
      default:语句；
  }
  ```

#### 循环结构

> 当满足条件时，重复的执行一段代码

##### for循环

```js
for(初始条件;终止条件;步进值){
    循环体;
}
```

##### while循环

```js
while(条件){
      添加为真时，执行循环体；
}
```

##### do while循环

```js
do{
    先执行一次循环体，再判断条件是否为真；
}while(条件)
```

##### 终止循环

- `break`           终止整个循环
- `countinue`   终止本次循环，如果后面的语句仍然满足条件，继续执行

### 数组

> 按照顺序排列的一组数据，数组中的每个元素都可通过下标去访问

#### 初始化数组

- 先声明后赋值

```js
var arr1 = [];
arr1[0] = 'p',arr1[1] = 'y',arr1[2] = 't',arr1[3] = 'h',arr1[4] = 'o',arr1[5] = 'n',
```

- 声明的同时赋值      

```js
var arr2 = ['p','y','t','h','o','n'];
```

#### 数据的遍历访问

> 访问数组中的每一元素

- 使用for循环访问

```js
var arr1 = [2018,6,16,9,19];
for(var i=0;i<arr1.length;i++){
    console.log(arr1[i]);
}
```

- 使用while循环遍历访问

```js
var i = 0;
var arr1 = [1,2,3,4,5,6,7,8]
while(i>arr1.length){
	console.log(arr1[i]);
	i++;
}
```

- 使用for in 进行遍历访问

```js
var arr1 = ['p','y','t','h','o','n']
for (var i in arr1){
    console.log(i);        //下标 
    console.log(arr[i]);   //元素
}
```

#### 二维数组

```js
var arr1 = [[1,2,3],[4,5,6],[7,8,9]];
# 遍历访问其元素
for(var i=0;i<=arr1.length;i++){
    for(var j=0;j<arr1[i].length;j++){
        console.log(arr1[i][j])
    }
}
```

#### 注意事项

- 数组元素的默认值为undefined
- 数组的长度是可变的
- 数组元素可以是任意数据类型

### 函数

> 将实现某一个功能的代码块封装起来，并能够重复调用

#### 函数的定义

- 使用function关键字定义函数

```js
function myfunction([形参]){
    函数体;
    [return 返回值;]
}
```

- 以自变量的形式定义一个函数

```js
var aa=function(){
    函数体；
}
aa();     #  调用函数
```

- 以对象的方式定义函数

```js
var person = new Object();
person.name="kevin";
person.age=31;
alert(person.name);
alert(person["name"])
```

#### 函数的调用

- 函数名+（）   functionName()
- 自变量+（）

#### 参数：

> 它能够动态改变函数体的变量，使函数更加灵活

- 形参：

  > 定义函数时，写在括号里的变量。形参的作用是接受实参 。

- 实参：

  > 函数调用时写在括号里的值。实参的作用是给形参传值。

#### 参数的传递

- 参数可以是任意的数据类型
- 按照顺序传递
- 形参 = 实参    :  一 一 对 应
- 形参 > 实参    ：多余的形参赋值为undefined
- 形参 < 实参    ：实参由`arguments`对象来接收

#### 参数的默认值：

- 分支结构
- 三元运算符
- 逻辑或
- es6  给形参赋值  当形参值为undefined时，会给形参赋默认值

#### arguments对象 ：（类似数组，不能用PUSH方法）

- 用来接收参数的详细信息
- 每声明一个函数，在其内部自动生成arguments对象，arguments对象只在函数内部起作用
- arguments[i]   arguments.length   遍历  类似数组但不是数组

#### 剩余参数

- 声明：`rest`
- rest参数与arguments对象的区别
  - rest接收多余实参，arguments接收全部实参
  - rest是数组，能够使用数组的方法；argument类似数组

#### 回调函数

> 把一个函数的指针（函数名）作为参数传给另一个函数，当指针调用函数时，这个函数叫做回调函数

#### 返回值：return

- 返回值可以是任意的数据类型
- return终止函数，return后面的代码不执行
- 如果函数没有返回值，则输出undefined

#### 递归：

> 一个函数不断的调用他本身，！！递归必须要有终止条件

```js
function factorial(num){
    if num<1{
        return 1;
    }
    return num*factorial(--num)
}
```

#### 闭包函数

> 能够在函数外部访问到函数内部的变量   

形成机制：在一个内嵌函数里面引用了外层函数的变量，且外部函数的返回值为内部函数。

#### 作用域  作用域链

> 变量起作用的范围

- 全局作用域

- 局部作用域

- 块级作用域

  ##### 全局作用域:

  > 在整个js代码中都能访问的变量，凡是进行修改，变量的值就会改变。

  - 在函数外部用`var`声明的变量，拥有全局作用域
  - 不用`var`声明，但赋值的变量，拥有全局作用域

  ##### 局部作用域:

  - 形参是局部变量，拥有局部作用域
  - 在函数内部用`var`关键字声明的变量，拥有局部作用域

  ##### let:

  - 声明变量，用法和`var`一致
  - 可以识别块级作用域
  - 不可以重复声明
  - 不存在变量提升（先访问后声明）

  ##### const:

  - 声明常量，一旦声明不能被改变
  - 声明的同时必须被赋值，否则会报错
  - const可以识别块级作用域
  - 不能重复声明，不存在变量提升

#### 内置顶层函数：

> 内置：ECMAscript自带的函数，只需要知道如何使用，不用关心如何封装
>
> 顶层：在代码的任意位置均能使用

- escape()    

  > 将输入的字符串进行编码

- unescape()

  > 将编码的字符串进行解码

- Boolean()

  > 将其余数据类型转换为布尔型
  >
  > 0  false undefined  NaN null ""

- String()

  > 将任意数据类型转换为字符串

- Number()

  > 将其余数据类型转换为数值型

  - null->0   ""->0   " "->0    
  - false->0   true->1
  - undefined->NaN
  - 进制数转换为十进制
  - 去掉没有意义的后导0
  - 字符串：规范的浮点数，数值型字符串

- parseInt()

  > 将字符串转换为整型
  >
  > 第一个开始的字母是数字（+，-，空格），转换不成功，转换为NaN

- parseFloat()

  > 将字符串转换为小数
  >
  > 仅能转换规范的浮点数.转换不成功,返回NaN

- isNaN()

  > 判断值是否能够转换为数值型，能转换为数值型返回false，不能返回true

#### 数据类型转换：

- 强制类型转换
- 隐式数据类型转换：算术运算符，逻辑运算符，条件if() while()

### 对象

#### 概念：

- 类：一群具有相同特征的对象集合的描述
- 对象：具体存在的对象个体
- 属性：对象基础信息的描述
- 方法：对象功能的描述

#### 定义对象：

- 构造函数（类），实例化对象

```js
function Computer(color){
    this.color=color;
    this.play=function(){
        console.log("敲代码");
    }
}
//实例化对象
let ASUS=new Computer("white");  
```

- JSON

```js
let ASUS={
    属性名：属性值，
    方法名：function(){
	}
}      //没有面向对象的特质，json js特有的一种存储数据的对象
```

- class定义类，实例化对象

```js
class game={
    method1(){}
    method2(){}
}
```

#### 属性：

> 对象.属性名=属性值

#### 方法：

> 对象.方法名=函数

#### 增删改查：

- 增加：  对象名.属性名=属性值
- 删除：  delete 对象名.属性名
- 修改：  对象名.属性名=属性值
- 访问：  对象名.属性名      对象["属性名"]     对象.方法()

#### 遍历：

```js
for (let i in apple){
    i；   //属性名
    apple[i];    //属性值
}
```

#### constructor:

> 对象的属性，返回该对象的构造函数

#### instanceof:

> `对象 instanceof 构造函数`  判断函数是否是对象的构造函数，是返回true ，不是返回false

### 常用的Math方法

Math.pow()

> 求幂次，Math.pow(3,6)=3^6;

Math.random()

> 取0-1的数，取不到1

Math.floor();

> 向下舍入，比如Math.floor(3/2)=1; 

Math.ceil();

> 向上舍入，比如Math.ceil(3/2)=2; 

Math.round();

> Math.round();四舍五入,比如Math.round(3/2)=2;Math.round(5/2)=2; 

